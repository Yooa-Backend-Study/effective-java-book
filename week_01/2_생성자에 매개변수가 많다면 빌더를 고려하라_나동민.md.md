# 생성자의 변수가 많다면 빌더패턴을 고려하라

***점층적 생성자 패턴***

말 그대로 생성자를 점층적으로 늘려가는 패턴

매개변수가 많아지거나 순서가 복잡해지면 클라이언트 코드를 작성할 때 헷갈리고, 읽기 어려움

** 개인적인 생각

- 컴파일에러가 런타임에러로 변질될 수 있다는 관점이 가장 큽니다
- 아래 예시와 같이 같은 파라미터 타입이 인자로 열거되어있을 경우 분명 의도와 다르게 동작하지만, 컴파일에서 잡을 수 없습니다.

```java
public class Test {
	private int el1;
	private int el2;
	private int el3;

	public Test(int el1, int el2, int el3) {
		this.el1 = el1;
		this.el2 = el2;
		this.el3 = el3;		
	}
}
```

- 또한 JPA같이 ORM을 쓰거나 하면 도메인 로직은 엔티티 클래스에 작성하는 경우가 많은데, 이때 점층적 생성자 패턴을 사용할 경우 읽기도 상당히 불편해집니다.

---

***자바빈즈 패턴***

이부분은 책과 조금 의견이 다릅니다.

자바빈즈 패턴은 분명 다음과 같은 단점이 있습니다.

- Setter를 통해 값을 세팅하므로 Setter를 여러개 호출해야 하고
- 객체가 완전히 세팅되기 전 까지는 일관성이 무너진 상태에 놓이게 된다.
- 또한 불변 클래스로 만들 수 없다.

다만 제가 생각하는 바는 다음과 같습니다.

- Setter를 완전히 피하는 것에 대한 필요성. (다만 Method 이름은 바꾸는 것이 좋습니다.)
- 이 책의 예시는 굉장히 극단적인 경우다. 빈 껍데기 객체만 만들어놓고 모든 필드를 setter를 통해 초기화하는 경우는 없다고 봐도 무방하다.
- 자바빈즈 패턴이 불변성을 보장하지 못하는 것은 사실이지만, 빌더나 다른 대안이 불변성을 지켜주는 것 또한 아니다.

빌더는 흔히 Immutable한 객체를 생성한다 라고 알려져있으나,

모든 파라미터가 Builder라는 메소드 체이징으로 엮여있고, Build()를 호출 하기 전까지는 객체가 생성되지 않을 뿐더러, Builder를 구현한 객체에 Setter를 열어놓지 않는다면,

Builder로 생성한 객체의 필드를 추후 수정할 수 없습니다. 여기까진 맞습니다.

다만 여기에는 Collection 필드 관련해서는 방어적 복사나 Unmodified 라이브러리도 동반되어야 하며, 모든 필드는 final로 이루어져야 하는 등의 추가적인 작업이 필요합니다. 물론 이 부분은 기본적인 관례처럼 행해지는 부분이긴 합니다.

즉, 저는 빌더 패턴이 불변성을 지키는 객체를 생성하기 위해서는 타 작업이 수반되어야 하기 때문에,  빌더 자체만으로 불변성을 지키는 객체를 만들 수 있다. 라는 주장에는 조금 애매하다고 생각하는 입장입니다.

---

***불변성을 강조하는 이유는 ?***

- 사이드 이펙트에 대한 걱정이 덜 함. ( Thread-Safe, Call By Reference )
- 추적이 굉장히 용이해짐. 운영 시 굉장한 장점으로 작용함.
- 내가 작성한 코드가 아니어도 믿고 사용할 수 있음.
- 실패 원자적 ( 로직 실행 전 후가 같음 )
- GC의 효율성

```java
public class MutableHolder {
    private Object value;
    public Object getValue() { return value; }
    public void setValue(Object o) { value = o; }
}

public class ImmutableHolder {
    private final Object value;
    public ImmutableHolder(Object o) { value = o; }
    public Object getValue() { return value; }
}
```
---

---

***빌더에 단점은 없는가 ?***

단점이라기 보다는 필드 2개 이하의 객체에서는 사용할 필요가 있는가 ? 하는 의문이 대표적이긴 합니다. 

다만, 별 생각없이 @Builder를 붙이는 개발자들이 많은 것은 사실이라고 생각합니다.

또한 @Builder 어노테이션 보다는 Builder의 직접 구현도 고려해볼만한 선택지라고 생각합니다.
