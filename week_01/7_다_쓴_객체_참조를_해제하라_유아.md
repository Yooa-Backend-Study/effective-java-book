# item 7 : 다 쓴 객체 참조를 해제하라

> p 36 ~ 39

- Java 애플리케이션은 JVM(Java Virtual Machine) 위에서 구동된다. JVM에서는 Java 애플리케이션이 사용하는 메모리를 관리하고 있는데, 이 JVM의 기능 중 더 이상 사용하지 않는 객체를 청소하여 공간을 확보하는 가비지 컬렉터(이하 GC)라는 작업이 있다.
- Java Runtime 시 Heap 영역에 저장되는 객체들은 따로 정리하지 않으면 계속해서 메모리에 쌓이게 되어 `OutOfMemoryException` 이 발생한다. WAS의 경우, 다운될 수가 있다.
- 이를 방지하기 위해 JVM에서는 주기적으로 사용하지 않는 객체를 수집하여 정리한다.

## JVM GC 동작 방식

Java의 GC는 매우 다양한 종류가 있지만 공통적으로 크게 다음 2가지 작업을 수행한다.

1. 힙(Heap) 내의 객체 중 가비지를 찾아낸다.
2. 찾아낸 가비지를 처리해서 힙의 메모리를 회수한다.

### GC의 수거 대상 기준: Reachability

- Java GC는 객체가 가비지인지 판별하기 위해서 **reachability**라는 개념을 사용한다.
- 유효한 참조가 있으면 'reachable'로 없다면 'unreachable'로 구별하고, **unreachable 객체를 가비지로 간주해 GC를 수행**한다.
- 한 객체는 여러 다른 객체를 참조하고, 참조된 다른 객체들도 마찬가지로 또 다른 객체들을 참조할 수 있으므로 객체들은 참조 사슬을 이룬다.
- 이런 상황에서 유효한 참조 여부를 파악하려면 항상 유효한 최초의 참조가 있어야 하는데 이를 **객체 참조의 root set**이라고 한다.

  - ![Alt text](https://d2.naver.com/content/images/2015/06/helloworld-329631-1.png)
  - (\* Java는 메모리를 사용하기 위해 Runtime Data Area에 영역별로 저장한다.)
  - java stack 영역의 데이터들, 즉 Java 메서드 실행 시에 사용하는 지역 변수와 파라미터들에 의한 참조
  - method 영역의 static 데이터에 의한 참조
  - JNI(Java Native Interface)에 의해 생성된 객체들

- ![rootset](https://d2.naver.com/content/images/2015/06/helloworld-329631-2.png)

  GC의 수거 대상은 GC Roots로부터 참조를 탐색했을 때, Unreachable한 Object들이다.

> 이처럼 가비지 컬렉션 언어에서는 (의도치 않게 객체를 살려두는) 메모리 누수를 찾기가 아주 까다롭다.
>
> 객체 참조 하나를 살려두면 가비지 컬렉터는 그 객체뿐 아니라 그 객체를 참조하는 모든 객체 (그리고 또 그 객체들이 참조하는 모든 객체..)를 회수해가지 못한다.

## GC 메모리 누수 예제 : Stack

간단하게 스택 코드를 구성하고 스택에 element를 push 했다가 pop하는 코드를 디버깅 해보자.

```java
public class Stack {
    private Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    public Stack() {
        elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }

    public void push(Object e) {
        ensureCapacity();
        elements[size++] = e;
    }

    public Object pop() {
        if (size == 0)
            throw new EmptyStackException();
        return elements[--size];
    }

    /**
     * 원소를 위한 공간을 적어도 하나 이상 확보
     * 배열 크기를 늘려야 할 때마다 대략 두 배씩 늘린다.
     */
    private void ensureCapacity() {
        if(elements.length == size) {
            elements = Arrays.copyOf(elements, 2 * size + 1);
        }
    }
}

public class Item07 {
    public static void main(String[] args) {
        Stack stack = new Stack();

        for(int i = 0; i < 5; i++) {
            stack.push(i);
        }

        for(int i = 0; i < 5; i++) {
            stack.pop();
        }
    }
}
```

![](https://velog.velcdn.com/images/jmjmjmz732002/post/82fbebaa-618e-46d0-808e-a5d9cce97e00/image.png)

![](https://velog.velcdn.com/images/jmjmjmz732002/post/45b67873-20fa-431a-9a0a-bcdba22a16a5/image.png)

위와 같이 단순히 elements의 size만 조절하며 객체를 꺼내고 있기에 실제 객체 참조는 살아있는 것을 확인할 수 있다.

가비지 콜렉터는 이러한 **다 쓴 참조(obsolete reference)는 회수하지 못한다.**
그래서 단 몇 개의 객체가 매우 많은 객체를 회수되지 못하게 할 수 있고 잠재적으로 성능에 악영향을 줄 수 있다.
⇒ `OutOfMemoryException` 이나 디스크 페이징을 발생시킬 수 있다!

해법은 간단하다. 해당 참조를 다 썼을 때 null 처리 (참조 해제)하면 된다.

```java
public Object pop() {
    if (size == 0)
        throw new EmptyStackException();
    Object result = elements[--size];
    elements[size] = null; // null 처리!!
    return result;
}
```

![](https://velog.velcdn.com/images/jmjmjmz732002/post/fd303d00-aa14-4beb-8734-1357c6b5e9e7/image.png)
![](https://velog.velcdn.com/images/jmjmjmz732002/post/9aaf8068-950f-49ff-be73-8e4c3492cc3c/image.png)

다 쓴 참조를 null 처리하면 null 처리한 참조를 실수로 사용하려 하면 프로그램은 즉시 NPE을 던지며 종료된다는 측면에서도 이점을 가진다고.

### 메모리 누수의 해결은 무조건적인 null 처리인가? NOPE!

- 모든 객체를 다 쓰자마자 일일이 null 처리할 필요도 없고 바람직하지도 않다. **프로그램을 필요 이상으로 지저분하게 만들 뿐이다.**
- 객체 참조를 null 처리하는 일은 **예외적인 경우**여야 한다.
  - 다 쓴 참조를 해제하는 가장 좋은 방법은 그 참조를 담은 변수를 유효 범위(scope) 밖으로 밀어내는 것.
  - 변수의 범위를 최소가 되게 정의했다면 이 일은 자연스럽게 이뤄진다.
    ⇒ 지역 변수를 가장 처음 쓰일 때 선언하기, 선언과 동시에 초기화하기 등 아이템 57에서 계속..✏️

# 메모리 누수의 주범 살펴보기

## 1. 자기 메모리를 직접 관리하는 클래스

`Stack` 클래스가 메모리 누수에 취약한 이유는 자기 메모리를 직접 관리하기 때문이다.

- 자기 메모리를 직접 관리한다는 것?
  - 배열로 저장소 풀을 만들어 원소를 관리하면서 비활성 영역의 참조 객체도 여전히 유효한 객체인 경우, GC는 이러한 정보를 알 수 없다.
  - 따라서 프로그래머가 비활성 영역의 참조 객체에 대해 null 처리를 해주며 GC에게 알려야 한다.
- 일반적으로 자기 메모리를 직접 관리하는 클래스는 항상 메모리 누수에 주의해야 한다고.👀

## 2. 캐시

1. 캐시 외부에서 키(key)를 참조하는 동안만 엔트리가 살아 있는 캐시가 필요한 상황 ⇒ `WeakHashMap`을 사용하기.

### WeakHashMap

- 강한 참조
  - `new` 할당 후 새로운 객체를 만들어 해당 객체를 참조하는 방식이다. 일상적인 프로그래밍에서 사용하는 가장 일반적인 유형의 참조.
  - 참조가 해제되지 않는 이상 GC의 대상이 되지 않는다.
- 소프트 참조
  - `SoftReference` 가 가리키는 객체는 JVM이 메모리를 절대적으로 필요로 할 때까지 GC의 대상이 되지 않는다.
  - ```java
    Integer prime = 1;
    SoftReference<Integer> soft = new SoftReference<Integer>(prime);
    prime = null;
    ```
  - 강한 참조를 null로 만든 후 주요 개체는 GC에 적합하지만 JVM에 메모리가 절대적으로 필요한 경우에만 수집된다.
- 약한 참조

  - `WeakReference` 클래스를 이용해 생성이 가능하다. 해당 객체를 가리키는 참조가 WeakReference뿐일 경우 null이 됐을 떄 GC의 대상이 된다.
  - ```java
    Person p1;
    Person p2;

    Person strong;
    WeakReference weak;

    public void Test() {
        p1 = new Person("yooa");
        p2 = new Person("jeongmin");

        strong = p1;
        weak = new WeakReference(p2);

        Console.WriteLine(strong == null ? "null" : strong.name);//yooa 출력
        Console.WriteLine(weak == null ? "null" : weak.name);//jeongmin 출력

        p1 = null;
        p2 = null;

        //GC 강제 수행
        System.gc();

        //강한참조는 strong이 참조하고 있으므로 객체가 해제되지 않았지만,
        //약한참조는 원본에 null 값을 넣으면 weak이 참조하고 있어도 객체가 해제된다.
        Console.WriteLine(strong == null ? "null" : strong.name);//yooa 출력
        Console.WriteLine(weak == null ? "null" : weak.name);//null 출력
    }
    ```

- WeakHashMap
  - WeakReference의 특성을 이용해서 HashMap의 element를 자동으로 GC해버린다. Key에 해당하는 객체가 더 이상 사용되지 않는다고 판단되면 제거한다는 의미이다.
  - ```java
    public static void main(String[] args) {
        WeakHashMap<Person, String> map = new WeakHashMap<>();
        Person p1 = new Fruit("yooa");
        Person p2 = new Fruit("jeongmin");
        map.put(p1, "test a");
        map.put(p2, "test b");
        p1 = null;
        System.gc();
        map.entrySet().forEach(System.out::println ); // test a의 결과는 출력되지 않음!!
    }
    ```
  - 이미지 ID를 key로, 이미지 개체를 value로 유지하는 캐시를 만들고 싶다고 할 때, value 개체가 많은 메모리를 사용할 수 있으므로 HashMap이 좋은 선택이 아닐 수 있다.
  - 애플리케이션에서 더 이상 사용하지 않을 경우에도 GC에 의해 캐시가 회수되지 않기 때문.
  - WeakHashMap을 사용해 이미지 ID key가 사용되지 않는 경우 해당 항목은 메모리에서 삭제되도록 구현할 수 있다.

2. 캐시를 만들 때 보통은 캐시 엔트리의 유효 기간을 정확히 정의하기 어렵기 때문에 시간이 지날수록 엔트리의 가치를 떨어뜨리는 방식을 흔히 사용한다.
3. 쓰지 않는 엔트리를 청소하기
   - (`ScheduledThreadPoolExecutor` 같은) 백그라운드 스레드를 활용하거나 캐시에 새 엔트리를 추가할 때 부수 작업으로 수행하는 방법이 있다.
   - `LinkedHashMap` 은 `removeEldestEntry` 메서드를 써서 후자의 방식으로 처리한다. 더 복잡한 캐시를 만들고 싶다면 `java.lang.ref` 패키지를 직접 활용해야 할 것이다.

### LinkedHashMap

- Map을 상속받았고, hashMap을 확장한 구조
- doubleLinkedList 형태
  - ![](https://velog.velcdn.com/images/jmjmjmz732002/post/6b89caed-4e0a-4e2e-a0b8-c559827a8a4e/image.png)
    단순 연결 리스트(linked list)와는 다르게 노드가 이전 노드(previous)와 다음 노드(next)로 구성되어 있는 형태이다. 즉, LinkedList를 이중으로 사용하여 요소의 순서를 유지하는 것
- HashMap과는 별도로 LinkedHashMap에서는 accessOrder 이라는 값을 가지고 있다.
  - ![](https://velog.velcdn.com/images/jmjmjmz732002/post/0b6b42f4-2dbf-490b-a86d-2f19445984ee/image.png)
- 만약에 이 값이 true면 `AfterNodeAccess` 접근하고 난 후 노드 처리를 하는 메서드, `AfterNodeInsertion` 노드를 추가하고 난 후의 처리를 하는 메서드를 호출하게 된다.
  ![](https://velog.velcdn.com/images/jmjmjmz732002/post/5b7bd5d1-d5bd-4296-9908-21646ccc1b16/image.png)
  특정 조건을 만족하면 제일 오래된 것을 제거하는 로직을 태우는데, 그 기준을 정해주는 것이 `removeEldestEntry`가 된다.

## 리스너(listener) 혹은 콜백(callback)

- 클라이언트가 콜백을 등록만 하고 명확히 해지하지 않는다면, 뭔가 조치해주지 않는 한 콜백은 계속 쌓여갈 것이다.
  - 콜백이란 다른 클래스에서 일부 작업이 완료된 경우 클래스에 완료되었다는 것을 알려주는 것.
  - 리스너는 특정 이벤트를 처리하는 인터페이스로 이벤트의 발생 여부를 기다리다가 이벤트 발생 시 해당 이벤트에 맞는 처리를 수행하는 객체.
- 이럴 때 콜백을 약한 참조(weak reference)로 저장하면 가비지 컬렉터가 즉시 수거해간다.
  - 예를 들어, `WeakHashMap` 에 키로 저장하면 된다.

---

### 참고

- [Java Reference와 GC](https://d2.naver.com/helloworld/329631)
- [Oracle docs : WeakHashMap](https://docs.oracle.com/javase/8/docs/api/java/util/WeakHashMap.html)
