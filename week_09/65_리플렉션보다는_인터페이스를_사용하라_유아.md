# Reflection

자바 어플리케이션이 컴파일되고 실행될 때, Class Loader는 자바 바이트코드(.class)를 읽어서 JVM 메모리에 저장합니다.

`Class<T>` 타입의 인스턴스를 만들어 Heap 영역에 넣어주어, 항상 있다는 것을 보장할 수 있기 때문에 아래와 같이 클래스를 만들기만 하면 바로 사용할 수 있습니다.

```java
class Person {
		private String name;

		public Person(String name) {
				this.name = name;
		}
}

Person person1 = new Person("yooa");
```

이러한 `Class<T>` 인스턴스는 해당 클래스에 정의된 멤버변수, 메서드, 생성자 등 클래스의 모든 정보에 접근할 수 있습니다.

`java.lang.reflect` Reflection은 객체의 구체적인 타입을 알지 못해도 힙 영역에 만들어지는 `Class<T>` 타입의 인스턴스를 통하여 해당 인스턴스의 멤버변수, 메서드 등에 접근할 수 있도록 해주는 기능입니다.

( JVM 메모리에 저장된 클래스에 대한 정보가 마치 거울에 투영된 모습과 닮아있어, 리플렉션이라는 이름을 갖게 되었다고👀. )

대표적으로 여러 라이브러리, 프레임워크에서 사용되는 어노테이션이 리플렉션을 사용한 예시입니다.

[아이템 39] 명명 패턴보다 애너테이션을 사용하라 > 발표에서 다루었던 `@Component` 와 같은 마커 어노테이션이 기억나시나요? 이 어노테이션들도 그 자체로는 아무 역할을 하지 않지만 리플렉션을 이용해서 프레임워크에서 기능을 할 수 있는 것이죠.

IDE에서 getter/setter를 자동 생성해주는 기능도 리플렉션을 사용해서 Field 정보를 가져와 구현한다고 하네요.

**런타임 시점에 정해지지 않은 인스턴스를 동적으로 조작할 수 있는 유연성을 제공**해주지만 주의하여 사용해야 합니다.

## 성능적 이슈

컴파일 이후에 생성된 자바 바이트코드는 JVM의 인터프리터를 통해 한 줄 씩 기계어로 번역되어 실행됩니다.

여기서 발생하는 성능 이슈를 해결하기 위해 여러 방식이 도입되었고, 그 중 JIT(Just-In-Time) 컴파일러는 캐싱을 통해서 한번 기계어로 번역된 메서드가 다시 실행되면 이전에 번역한 것을 사용할 수 있게 하는 방식으로 최적화합니다.
![](https://velog.velcdn.com/images/jmjmjmz732002/post/c7d24b4d-b1f5-4845-847e-f6b2156620da/image.png)

reflection은 클래스의 바이트코드를 이용하는 것이 아니라, 메모리에 올라간 (클래스의 특성을 투영한) 데이터를 이용하므로 같은 메서드를 재호출하더라도 최적화가 되지 않습니다.

또한 reflection은 type 정보를 사용하지 않고 동작하기에 컴파일러가 제공하는 type checking을 받지 않습니다. 이러한 typeless의 특징으로 존재하지 않는 메서드를 호출하는 등의 시도로 발생하는 런타임 오류에 대해 추적이 불가능합니다.

더하여, reflection을 이용하면 보통 경우에 접근 불가한 private 필드와 메서드에도 접근할 수 있고 이는 캡슐화를 깨뜨리는 결과를 가져오기도 합니다.

### 비판적으로 바라보자면?

그러면, **Reflection을 사용한 코드는 언제나 느리고, 복잡하고, 에러가 발생하기 쉽고, 디버깅이 어려운걸까요?**

개발자들 사이에 공공연히 진실로 받아들여지는 이 말은 사실이 아니라는 주장도 있습니다. 적절히 사용한 Reflection은 오히려 성능을 향상시킬 수 있으며, 또한 많은 이득을 제공할 수 있습니다.

### 1. 언제나 느릴까?

아래는 Dennis Sosnoski(5. Java Programming dynamics, Part 2: Introducing reflection)가 측정한 Reflection에 관한 성능 결과에 따르면, Reflection을 사용할 경우 직접(Direct) 또는 참조(Reference)의 경우에 비해 2 ~ 4배 정도 느리다고 하네요.

이 결과를 통해 알 수 있는 사실은 “Reflection에 따른 성능 저하”가 아니라 “성능 측정 결과, Reflection을 사용한 **지금 이 경우에는** 성능이 저하되는 것을 검증했다”라는 것입니다.

최적화 또는 성능 개선(Optimization)시 유의해야 할 점은 반드시 최적화 이전과 이후의 성능을 측정하여, 성능개선이 가시적으로 보일 때에만 적용해야 한다는 것입니다.

> 무지성 회피 멈춰!!! 아이템 67 : 최적화는 신중히 하라의 원칙을 따라봅시다.

### 2. 언제나 에러가 발생하기 쉽고, 디버깅이 어렵다?

Reflection은 실제 클래스 없이 클래스의 이름 또는 메서드의 이름만을 이용합니다. 따라서, 컴파일 시점에는 Type Checking을 하지 않습니다.

대신, 실행시 발생할 수 있는 Exception을 처리하기 위한 try/catch문을 추가해야 합니다.

Reflection 사용에 따른 Exception으로부터 복구할 수 있는 상황이란 거의 없다고 합니다.

예를 들어, Class Not Found Exception이 발생한다면, 이는 클라이언트가 잘못된 클래스 명을 넘겨주었거나 또는 해당 클래스가 없을 2가지 경우겠죠. 이는 모두 프로그램 에러 상황으로 오히려 Run-time Exception에 가깝습니다.

결국, Reflection을 사용함으로써, 컴파일 시점에 조기에 발견될 수도 있었을 프로그램 에러들이 런타임시에 발생하게 되는 것이죠. 이처럼 에러 상황이 늦게 발견하면 디버깅이 어려워지게 됩니다. 이와 같은 경우를 위해서, 런타임시 디버깅을 위해 상세한 에러 메시징 기능을 포함하는 것이 좋습니다. (디버깅이 쉬운 환경으로 만드는 것!)

> 디버깅이 어려운 것은 컴파일 단계에 처리할 수 있는 오류들이 실행 단계에 발생하기 때문이 아니다. 더
>
> 근본적인 이유는 Reflection을 사용할 경우에 발생할 런타임 에러 메시지를 최대한 상세하게 그리고 친절하게 표시하도록 Exception 전략을 설계하지 못했기 때문이다.
>
> 잘 설계된 Exception 처리 전략은 Reflection 뿐만 아니라 시스템의 전체적인 디버깅을 쉽게 만든다.

### 3. 언제나 코드가 복잡하고 리팩토링이 어렵다?

Reflection을 사용한 코드는 일반적인 객체 생성, 메서드 호출 코드에 비교하면 복잡한 것이 사실입니다.

하지만 클래스의 타입을 비교하여 객체를 생성하는 코드의 경우, 대량의 if/else문을 사용하는 것보다 Reflection을 이용하여 재사용 가능한 컴포넌트로 만든다면, 오히려 코드를 단순화한다고.

## 리플렉션 어떻게 활용해야 할까?

Reflection의 복잡성은 사실 개발자 개개인의 초점에 맞추었을 때의 이야기입니다.

하지만, Reflection은 개발자 관점이 아니라 아키텍트 중심으로 설계가 되어야 합니다. 시스템 아키텍처를 이루는 컴포넌트에서 가장 유용하게 쓰이기 때문입니다. 잘 설계된 Reflection이 서비스 개발을 단순화시킬 수 있습니다.

Reflection을 적절히 사용했고 이에 따라 많은 이득이 있다고 판단이 되더라도,

더 간단한 해결책이 있다면 (책 예시처럼 인터페이스 대체로 해결이 가능한 것 처럼) Reflection을 사용하지 않는 것이 좋다고 생각합니다. 결국 최상의 선택을 해내는 것이 개발자의 몫이라고 봅니다.

---

ref

**[자바 리플렉션에 대한 오해와 진실](https://kmongcom.wordpress.com/2014/03/15/%EC%9E%90%EB%B0%94-%EB%A6%AC%ED%94%8C%EB%A0%89%EC%85%98%EC%97%90-%EB%8C%80%ED%95%9C-%EC%98%A4%ED%95%B4%EC%99%80-%EC%A7%84%EC%8B%A4/)**

**[리플렉션(Reflection)](https://medium.com/@gksrlfw/%EB%A6%AC%ED%94%8C%EB%A0%89%EC%85%98-reflection-%EC%9D%B4-%EB%8A%90%EB%A6%B0-%EC%9D%B4%EC%9C%A0-a567edf80353)**
