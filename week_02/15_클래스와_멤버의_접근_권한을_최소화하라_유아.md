# [아이템15] 클래스와 멤버의 접근 권한을 최소화하라

p. 96~101

## 정보 은닉, 캡슐화

잘 설계된 컴포넌트를 ‘캡슐화를 잘 지켰는지’로 기준을 둔다.

> 캡슐화(Encapsulation) : 객체의 속성(data fileds)과 행위(methods)를 하나로 묶고, 실제 구현 내용 일부를 외부에 감추어 은닉한다.

즉, 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐가 잘 설계된 컴포넌트를 결정한다. 이 개념은 소프트웨어 설계의 근간이 되는 원리라고.

### 장점

- **시스템 개발 속도를 높인다.** 서로 독립된 컴포넌트를 다수의 개발자가 동시에 개발할 수 있다.
- **시스템 관리 비용을 낮춘다.** 시스템의 일부 컴포넌트에서 오류가 발생했을 때, 해당 컴포넌트만 검사하면 된다.
- **성능 최적화에 도움을 준다.** 컴포넌트 간의 상호 의존성을 최소화하고, 각 컴포넌트를 독립적으로 최적화할 수 있다. 각 컴포넌트가 독립적으로 최적화되었기 때문에, 한 컴포넌트의 최적화가 다른 컴포넌트에 영향을 미치지 않는다.
- **소프트웨어 재사용성을 높인다.** 정보 은닉을 염두에 두고 설계된 컴포넌트는 자신만의 인터페이스(API)를 제공한다.
- **큰 시스템을 제작하는 난이도를 낮춰준다.** 각 컴포넌트는 내부 동작을 숨기고 명확한 API를 제공하므로 해당 컴포넌트의 동작을 분리된 단계에서 검증할 수 있다.

## 접근 제어 매커니즘

자바의 접근 제어 매커니즘은 정보 은닉을 위한 중요한 원칙 중 하나로, **모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다**는 기본 원칙을 강조한다.

### 톱레벨 클래스의 접근 수준

자바에서 클래스와 인터페이스는 **톱레벨 클래스**로 구분되며, 톱레벨 클래스와 인터페이스에 부여할 수 있는 접근 수준은 **pacakage-private(default)과 public** 두 가지다.

1. package-private(default) : 클래스나 인터페이스에 접근 제한자를 명시하지 않을 때 적용되는 **가장 좁은 접근 수준**. 클래스나 인터페이스가 속한 패키지 내에서만 접근할 수있으며, 패키지 외부에서는 접근할 수 없다.
2. **public**: 클래스나 인터페이스를 **공개 API로 선언**할 때 사용되는 접근 수준. 클래스나 인터페이스는 패키지 외부에서도 접근 가능하며, 다른 패키지의 코드에서 사용할 수 있다.

package-private은 클래스나 인터페이스는 패키지의 내부 구현에 속하게 되며 외부에서 직접 접근할 필요가 없는 경우에 사용되며, public은 다른 개발자가 사용하는 API의 일부가 되므로 하위 호환성을 유지하고 관리해야 한다.

**public일 필요가 없는 클래스의 접근 수준을 package-private 톱레벨 클래스로 좁히는 일은 중요하다.** public 클래스는 패키지 외부에서 접근 가능한 API인 반면, package-private 톱레벨 클래스는 API로서 노출되지 않고 내부 구현에 속하기 때문이다.

### private static 중첩

사람(Person)의 주소(Address)를 나타낸다고 가정해보자.

우선, 사람의 주소를 나타내는 `Address` 클래스를 만들고, 해당 클래스는 패키지 내에서만 사용해야 하므로 package-private으로 만든다.

```java
package week_02.item_15;

class Address {
    // 주소 표현
}
```

`Address`는 톱레벨로 선언되어 동일 패키지 내의 다른 클래스에게 노출되며 접근 가능한 상태가 된다. `Person` 클래스에서만 사용하는 클래스이므로 이를 private static으로 중첩시켜 보자.

```java
package week_02.item_15;

public class Person {
    private String name;
    private int age;
    private Address address; // 중첩 클래스 사용

    private Person(String name, int age, String street, String city, String zipCode) {
        this.name = name;
        this.age = age;
        this.address = new Address(street, city, zipCode);
    }

    public static Person createPerson(String name, int age, String street, String city, String zipCode) {
        return new Person(name, age, street, city, zipCode);
    }

		// private static 중첩
    private class Address {
        private String street;
        private String city;
        private String zipCode;

        public Address(String street, String city, String zipCode) {
            this.street = street;
            this.city = city;
            this.zipCode = zipCode;
        }

        public String getFullAddress() {
            return street + ", " + city + ", " + zipCode;
        }
    }
}
```

```java
package week_02.item_15;

public class Item15 {
    public static void main(String[] args) {
        Person person = Person.createPerson("유정민", 23, "북내면 신남1길 35-8", "여주시", "12613");
        Person.Address address; // 생성 불가
        String fullAddress = person.getAddress(); // 여주시, 북내면 신남1길 35-8, 12613

    }
}
```

`Person` 클래스는 `Address` 정보를 내부적으로 중첩되어 갖고 있다. 이를 통해 `Address` 클래스의 접근 수준은 `Person` 클래스 내부에서만 사용 가능하고 외부에서 직접 접근할 수 없다.

## 접근 제한자

멤버(필드, 메서드, 중첩 클래스, 중첩 인터페이스)에 부여할 수 있는 접근 수준은 네 가지다.

- private : 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다.
- package-private(default) : 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다. 접근 제한자를 명시하지 않았을 때 적용되는 패키지 접근 수준이다. (단, 인터페이스의 멤버는 기본적으로 public으로 적용된다.)
- protected : package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.
- public : 모든 곳에서 접근할 수 있다.

### 멤버 접근 수준 관리하기

클래스의 공개 API를 세심히 설계하는 것은 중요하다. 공개 API는 다른 클래스 또는 모듈에서 사용할 수 있는 메서드, 필드, 인터페이스 등을 의미한다. 이러한 공개 API는 주로 클래스의 기능과 서비스를 제공하기 위한 것.

그 외의 모든 멤버는 private으로 만든다. 이렇게 하면 클래스 외부에서는 해당 멤버에 직접 접근할 수 없다. 클래스 내부에서만 사용되는 부분을 private으로 선언하여 은닉성을 유지한다.

그러나 동일한 패키지의 다른 클래스에서 해당 멤버에 접근해야 하는 경우가 있다. 이런 경우에는 private 제한자를 제거하고 package-private으로 변경한다. 이렇게 하면 동일한 패키지의 다른 클래스에서 해당 멤버에 접근할 수 있다.

이러한 권한을 풀어주는 작업이 자주 수행된다면 컴포넌트를 더 분해할 필요가 있는지 다시 고민해봐야 한다고.👀 컴포넌트를 더 작게 나누면 각 컴포넌트는 더 독립적으로 개발하고 테스트할 수 있으므로 시스템을 유지보수하거나 확장하기가 더 쉬워지기 때문이다.

마지막으로, **`Serializable`**을 구현한 클래스에서는 private 또는 package-private로 선언된 필드들도 직렬화의 영향을 받을 수 있다. 직렬화는 객체를 바이트 스트림으로 변환하는 과정이며, 직렬화된 객체를 역직렬화하여 다시 객체로 복구할 수 있어야 한다. 이때 private 필드들도 역직렬화 과정에서 접근될 수 있으므로 주의해야 한다.

### public 클래스의 protected 멤버

public 클래스에서는 멤버의 접근 수준을 package-private에서 protected로 바꾸는 순간 그 멤버에 접근할 수 있는 대상 범위가 엄청나게 넓어진다. 이는 protected 멤버를 사용하는 클래스의 수가 많아질 수 있다는 것을 의미한다. 그러면 이러한 멤버를 유지, 관리하고 또한 변경할 때 유의해야 한다는 것.

public 클래스의 protected 멤버는 공개 API의 일부이므로 해당 멤버를 제거하거나 변경하는 것은 하위 호환성을 깨뜨릴 수 있다. 따라서 protected 멤버의 수는 최소화하는 것이 좋다고.

### 상위 클래스 재정의 시 멤버 접근성 제약

멤버 접근성을 좁히지 못하게 방해하는 제약이 하나 있다. 상위 클래스의 메서드를 재정의할 때는 그 접근 수준을 상위 클래스에서보다 좁게 설정할 수 없다는 것.

이 제약은 상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야 한다는 규칙(리스코프 치환 원칙)을 지키기 위해 필요하다. 이 규칙을 어기면 하위 클래스를 컴파일할 때 컴파일 오류가 난다.

> 💡 리스코프 치환 원칙
>
> 하위 클래스(subclass)가 상위 클래스(superclass)를 대체할 수 있어야 한다는 소프트웨어 공학 원칙 중 하나
>
> **만약 S가 T의 하위타입(subtype)이라면, T타입의 객체에 대한 각 T타입의 객체를 사용하는 프로그램에서 S타입의 객체를 사용해도 프로그램의 의미는 변해서는 안 된다.**

```java
class Superclass {
    public void performAction() {

    }
}

class Subclass extends Superclass {
    @Override
    public void performAction() {

    }
}
```

이때 `performAction` 메서드의 접근 수준을 `protected`나 `private` 로 변경할 수 없습니다. 왜냐하면 리스코프 치환 원칙에 따라서 `Subclass`는 `Superclass`를 대체할 수 있어야 하며, 클라이언트 코드에서 이를 활용할 때 어떤 메서드든 기대한 동작을 보장받아야하기 때문이다.

클래스가 인터페이스를 구현하는 경우, 인터페이스에서 정의한 메서드는 항상 `public`으로 선언되어야 한다. 인터페이스를 구현하는 클래스는 인터페이스의 모든 메서드를 구현해야 하며, 이들 메서드는 인터페이스에서 정의한 시그니처(메서드 이름, 매개변수, 반환값)을 따라야 한다. 이것은 인터페이스를 사용하는 클라이언트 코드가 인터페이스의 메서드를 호출할 수 있도록 보장하기 위한 규칙이다.

### 테스트 목적의 접근 범위를 넓히는 경우

> 단지 코드를 테스트하려는 목적으로 클래스, 인터페이스, 멤버의 접근 범위를 넓히려 할 때가 있다. 적당한 수준까지는 넓혀도 괜찮다. 예를 들어, public 클래스의 private 멤버를 package-private까지 풀어주는 것은 허용할 수 있지만, 그 이상은 안 된다.

어떤 상황에서 허용이 되며 합리적인지를 고민해 봤을 때,

1. 단위 테스트에서 테스트 코드가 테스트 대상 코드에 접근하는 경우가 있을 것 같다. 단위 테스트에서는 테스트 대상 클래스의 내부 상태나 메서드를 검증해야 한다. 이때 단위 테스트 클래스는 테스트 대상 클래스와 같은 패키지에 위치하고, package-private 멤버에 접근할 수 있다.
2. Mock 객체를 생성하고 테스트 대상 객체를 감시(spy)할 때, package-private 멤버에 접근해야 한다.
3. 상속을 이용하여 테스트 대상 클래스를 확장한 서브클래스를 생성하고 package-private 멤버를 활용하는 경우도 있을 것 같다.

### public 클래스의 인스턴스 필드 접근 제한

- **public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다**.
  - 필드 값을 직접 수정하거나 가져올 수 있으면 클래스 불변성이 보장되지 않고, 특히 가변 필드라면 그 필드 내용을 제어할 방법이 없다.
  - 예상하지 못한 side-effect를 방지.
- **public 가변 필드를 갖는 클래스는 일반적으로 thread-safe하지 않다.**
  - 다른 스레드에서 필드 접근 및 수정이 가능하면 필드 상태를 예측할 수 없다. 그러므로 스레드 안정성(thread safety)을 보장하지 못한다.
  - 스레드 안전성은 상태 및 상태 변경에 대한 접근을 조율하고 데이터에 동시 접근을 관리하는 것을 의미하기 때문.
- public final로 **불변 객체 활용한다면** 가변 상태의 문제를 회피할 수는 있다. 다만, 내부 구현을 바꾸는 것에 한계가 생긴다. (public 필드를 없애는 등 리팩터링 불가)

### 상수 필드의 접근성

1. **상수(static final)로 공개해도 좋은 경우:** 만약 해당 클래스가 표현하는 추상 개념을 완성하는 데 꼭 필요한 상수라면 public static final 필드로 공개해도 괜찮다. 이런 필드는 해당 클래스와 관련이 깊고, 불변해야 한다.
2. **반드시 기본 타입 값이나 불변 객체를 참조해야 함:** 공개된 상수 필드가 가변 객체를 참조하면 문제가 발생할 수 있다. 왜냐하면 상수로 공개된 필드를 통해 수정이 불가능하더라도, 참조된 가변 객체 자체는 수정될 수 있기 때문. 따라서 이러한 상수는 기본 타입 값이나 불변 객체를 참조해야 한다

상수는 코드 가독성을 높이고, 해당 클래스와 관련된 중요한 정보를 제공하는 데 도움이 된다. 상수를 사용할 때에는 명확한 목적과 의미를 가진 이름을 선택하고, 상수 필드의 값은 변경되지 않아야 하는 것이 중요.

### 배열을 멤버로 다루는 법

```java
public static final Thing[] VALUES = { ... };
```

길이가 0이 아닌 배열은 모두 변경 가능하니 클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안 된다. 이런 필드나 접근자를 제공한다면 클라이언트에서 그 배열의 내용을 수정할 수 있게 되기 때문.

(다만, 클래스가 가변 배열을 유지해야 하는 케이스라면 적합하지 않을 수 있다.)

해결책은 두 가지다.

첫 번째 방법은 앞 코드의 public 배열을 private으로 만들고 public 불변 리스트를 추가하는 것

```java
private static final Thing[] PRIVATE_VALUES = { ... };
public static final List<Thing> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
```

두 번째는 방어적 복사. 배열을 private으로 만들고 그 복사본을 반환하는 public 메서드를 추가하는 방법

```java
private static final Thing[] PRIVATE_VALUES = { ... };
public static final Thing[] values() {
		return PRIVATE_VALUES.clone();
}
```

책에서 안내된 두 번째 방법인 **`clone`** 메서드를 활용한 ‘방어적 복사’는 새로운 메모리 공간에 값을 복사하게 되지만, 원소가 기본 타입이 아닌 참조 타입이기에 해당 주소값도 동일하게 복사되고 따라서 복사 배열을 통해 해당 참조에 접근하게 되면 원본 배열에도 영향을 준다.
![](https://velog.velcdn.com/images/jmjmjmz732002/post/cac8bc0a-8bcb-4705-8d63-f783a03c23cd/image.png)

```java
Thing[] notSafe = Example.values();
notSafe[0].setA("abc"); // Thing 클래스 내부 필드를 변경하면 원본 배열에도 영향을 줌!
```

따라서, 배열 원소의 클래스를 final을 이용하여 불변으로 만들건, 클래스 자체에 clone을 구현해서 깊은 복사(deep copy)가 이루어지도록 하는 등 대처가 필요하다. 메모리 측면에서 성능이 저하될 수 있는 문제가 발생할 수 있으므로 고려를 통해 합리적인 방법을 택해야 한다.

# 모듈 시스템

Java 9는 공식적으로 Java Platform Module System (JPMS) 또는 줄여서 '모듈'이라고 알려진 새로운 수준의 추상화를 도입한다. 모듈이란 서로 밀접하게 연관된 패키지들과 리소스들의 그룹이다. 즉, "자바 패키지들의 패키지(package of Java Packages)"라고도 볼 수 있는데, 이는 코드의 재사용성을 높이기 위해 추상화 단계를 하나 더 추가한 것이라고 볼 수 있다.

모듈에는 Public API를 내보내고 구현 세부 정보를 숨김/비공개 상태로 유지할 수 있다. protected 혹은 public 멤버라도 해당 패키지를 공개하지 않았다면 모듈 외부에서 접근할 수 없다. 모듈 시스템을 활용하면 클래스를 외부에 공개하지 않으면서도 같은 모듈을 이루는 패키지 사이에서는 자유롭게 공유할 수 있다.

이러한 기능은 일반적으로 클래스나 패키지를 재배치하거나 모듈 간의 의존성을 조절해야 하는 특별한 상황에서 사용된다고.

### 주의점

모듈을 JAR 파일로 패키징할 때, 이 JAR 파일을 자신의 모듈 경로(모듈 경계 내부)가 아닌 애플리케이션의 classpath(모듈 경계 외부)에 위치시킨다면 해당 모듈의 모든 패키지는 모듈 경계를 벗어난 것처럼 작동하게 된다. 즉, 이 모듈의 패키지와 클래스는 모듈 시스템의 보호 밖에서 접근 가능해지는 것

이 접근 수준을 적극 활용한 대표적인 예가 바로 JDK 자체다. 자바 라이브러리에서 공개하지 않은 패키지들은 해당 모듈 밖에서는 절대로 접근할 수 없다.

모듈 내의 클래스나 패키지를 외부에서 접근할 수 있도록 모듈을 제대로 구성하지 않으면 모듈 시스템의 이점을 누리기 어려울 수 있다고. 패키지 구조를 재구성하고, 모듈 간의 의존성을 명시하는 작업을 필요로 하며, 모듈 외부에서 모듈 내부로의 접근에 대한 특별한 주의가 필요하다고 한다.

러닝 커브와 프로젝트의 복잡성 볼륨이 커지는 것을 고려했을 때, 작은 프로젝트에는 모듈 시스템을 도입하지 않는 것이 현명한 판단일 수 있겠다.
