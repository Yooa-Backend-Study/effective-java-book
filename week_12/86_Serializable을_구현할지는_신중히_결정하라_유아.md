> Serializable을 구현하면 릴리스한 뒤에는 수정하기 어렵다.

Serializable 인터페이스를 구현하면 해당 클래스의 객체는 **자동으로 직렬화 가능한 객체로 간주되어** 직렬화 프레임워크에 의해 객체의 상태를 바이트 스트림으로 인코딩됩니다.

**이 바이트 스트림은 어떤 형태로든 외부에 노출될 수 있습니다.**

아이템 85에서 살펴본 Apache의 InvokerTransformer가 취약점에 대응한다고 직렬화를 삭제해버렸고 이로 인해 호환성이 망가지는 등 다양한 문제를 초래했다는 내용 기억하시나요?

바로 이 챕터의 핵심이라고 봐주시면 됩니다.

만약 Serializable을 구현한 클래스의 바이트 스트림 형식을 변경하고 그것을 기존에 사용되고 있는 코드들이 읽어들일 때, 예전 형식에 맞게 읽을 수 없게 되어 버리면 호환성 문제가 발생하게 됩니다.

---

이번엔 다른 상황을 가정해봅시다. Serializable을 구현한 클래스의 내부 구현이 변경되어 원래 직렬화 형태와 달라지게 된다면 어떻게 될까요?

-> 구버전과 신버전 간의 호환성 문제가 발생할 수 있습니다.

아래 시나리오를 한번 보시져.

1. 클래스의 내부 구현이 변경되어 새로운 버전이 릴리스되었습니다.

2. 사용자가 구버전의 클래스를 사용하여 객체를 직렬화하고 저장했습니다.

3. 새로운 버전의 클래스로 업데이트한 후에, 이전에 저장한 직렬화된 객체를 역직렬화해봅니다.

4. 클래스의 내부 구현이 변경되었기 때문에, 새로운 버전에서는 이전 버전의 직렬화 형태를 처리하다가 예외가 터집니다.

그리고 제 머리도 터집니다.

결국 신버전 하나를 릴리즈 하기 위해서는 신버전 인스턴스를 직렬화하고 이를 구버전으로 역직렬화할 수 있는지, 그 반대도 가능한지를 검사하는 과정을 거쳐야 하고

테스트 과정이 릴리즈 횟수에 비례해 어마무시한 부담이 생기게 되겠죠.

# 캡슐화도 위반해

Serializable을 구현하면 해당 클래스의 모든 필드, 즉 private이나 package-private으로 선언된 필드들도 직렬화의 대상이 됩니다.

객체의 상태를 외부로 노출시키는 측면에서 캡슐화의 원칙을 어기게 됩니다.

(\* 직렬화 대상에서 제외시킬 필드에 대하여 transient 키워드를 사용하는 방법도 있습니다.)

---

결론은 Serializable을 구현하기 위해서는 위오 같은 이슈에 대해 충분히 대응 가능하냐를 따져야 하는 것 같습니다. (위 같은 이슈가 터질 수 있다는 것을 인지하고 터지지 않을 자신이 있다면 구현해라.. )

이러한 이슈에 대응하는 비용 측면을 생각해봤을 때 아이템 85번의 결론과 같이 '반드시 필요한게 아니면 지양하자'가 되어버리는 것 같습니다.
