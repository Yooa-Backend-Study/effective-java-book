# Thread Scheduler

스레드의 실행 시점을 관리하는 역할을 한다.

"언제 실행 가능한 상태로 움직여야 할 지"

"언제 실행중인 상태를 종료해야 할 지"

"종료 후 스레드를 어디로 보내야 할자"

사용자가 제어할 수 없고, 제한된 자원을 여러 프로세스가 효율적으로 사용하도록 다양한 policy를 갖고 할당한다. os마다 policy 다르므로 스케줄러 방식도 달라질 수 있다.

> 정확성이나 성능이 스레드 스케줄러에 따라서 달라지는 프로그램이라면 다른 플랫폼에 이식하기 어렵다.

서로 다른 운영체제나 환경에서는 스레드 스케줄러의 동작이 다를 수 있으며,

우리의 프로그램이 스레드 스케줄러의 policy에 따라 '이상하게' 동작한다면 우리가 제어할 수 없다는 것.

# 견고하고 이식성 좋은 프로그램을 작성하기 위해서 고려해야 할 것들

    ◦  실행 가능한 스레드의 평균 개수를 프로세서 수 보다 지나치게 많아지지 않도록 관리할 것

    ◦  즉 실행가능한 스레드 수를 가능한 적게 유지하는 것이 중요하다.
    (* 실행 가능한 스레드 수 == wait 상태의 스레드)

기존의 자바 3전까지는 green thread 방식을 이용했다.

kernel thread 1개가 이 JVM에 매핑되고 JVM 내부적으로 자바 라이브러리가 user-threads를 매핑하는 ManyToOne 모델이다.

이 방식의 단점은 하나의 커널 스레드가 내부적으로 여러가지 스레드를 수행할 수 없다는 것. 그렇다면 자연스럽게 user thread 들은 block이 생기게 된다. 아래 그림을 참조하자.
![](https://velog.velcdn.com/images/jmjmjmz732002/post/0bc97869-abc8-4a82-a2e5-a89093c130ff/image.png)

3 이후부터는 Native Thread 방식으로 바뀌게 되었는데 여러 개의 커널 스레드와 여러 개의 유저 스레드를 매핑하는, 즉 ManyToMany 방식으로 바뀌었다는 뜻이다.

이렇게 되었으니 스레드 스케줄링은 OS가 가지고 가게 되고, 내부적으로 유저 스레드를 통해서 각 스레드들을 관리하는 것이다.
![](https://velog.velcdn.com/images/jmjmjmz732002/post/2a3b9780-5ca2-443f-87ed-8c52b569331a/image.png)

# 당장 처리할 작업이 없다면 실행하지 않기

Thread pool size를 적절하게 설정하고, 작업은 짧게 유지한다.
너무 짧으면 작업 분배 부담이 커져 성능을 떨어뜨릴 수 있으니 주의해야 한다.

바쁜 대기(Busy Waiting)에 빠지지 않도록 스레드를 관리해야 한다.

> 바쁜 대기(Busy Waiting)
> ![](https://velog.velcdn.com/images/jmjmjmz732002/post/e56abf87-06df-4618-b5a8-5623d0bf1795/image.png)
> 원하는 자원을 얻기 위해 기다리는 것이 아니라 권한을 얻을 때까지 확인하는 것
> => 권한 획득을 위해 많은 CPU를 낭비한다는 단점이 존재한다.

# Thread.yield 사용 주의하기

yield() 메소드를 호출한 스레드는 실행 대기 상태로 돌아가고 동일한 우선순위 또는 높은 우선순위를 갖는 다른 스레드가 실행 기회를 가질 수 있도록 해준다.
(관대한 양보라고도 표현한다)

실행 가능한 스레드가 없다면 시간이 단순하게 소진될 우려도 있고, 테스트할 수단이 없어서 jvm 버전이나 종류에 따라 성능을 보장할 수가 없다.

# 스레드 우선순위 조절하기

스레드 우선순위를 조절할 수도 있지만, yield 사용 때와 비슷한 위험이 있다. **스레드 우선순위는 자바에서 이식성이 가장 나쁜 특성이다.**

스레드 몇 개 우선순위 조율해서 애플리케이션 반응 속도를 높일수도 있지만 그래야할 상황은 드물고 이식성도 떨어진다.

심각한 응답 불가 상태는 진짜 원인을 찾아 수정하기 전까지 같은 문제가 반복해서 터질 것이다.
